/// This script smears jets and recomputes quanities needed for to run through plotEvent
// To run this, it only takes the ntuple name and produces a new ntuple
// root -l -q smearPhJets.C\(\"SinglePhoton\",\"A\"\)
// the 2nd input is the MC period. Either A, D or E. It sets the seed for the random number generator used for jet smearing so that ntuples are generated with different smearing
// The code assumes that the input files are in a directory called /tmp/v41Agam
// The output is an ntuple that can be used to make the normal selections called  /tmp/v41Agam/smallv2SinglePhoton.root // note the A should change to a D or E


//
// Sorting algorithm
//
struct JetStruct {

  JetStruct() {}

  float Pt() { return jet_vec.Pt(); }
  float Eta() { return jet_vec.Eta(); }
  float Phi() { return jet_vec.Phi(); }
  float M() { return jet_vec.M(); }
  
public:
  float jet_pt;
  float jet_eta;
  float jet_phi;
  float jet_m;
  float jet_jvt;
  float jet_fjvt;
  float jet_btag_weight;
  float jet_timing;
  int jet_PartonTruthLabelID;
  int jet_ConeTruthLabelID;
  TLorentzVector jet_vec;
};

struct SortPhysicsObject {
  
  SortPhysicsObject(const std::string &key = "") :fKey(key) {}
  
  //template<class M, class T>
  bool operator()(const TLorentzVector &lhs, const TLorentzVector &rhs) const{
    //
    // Sort based on pt 
    //
    return lhs.Pt() > rhs.Pt();
  }
  bool operator()(const TVector3       &lhs, const TVector3       &rhs) const{
    //
    // Sort based on pt 
    //
    return lhs.Pt() > rhs.Pt();
  }
  bool operator()(const JetStruct       &lhs, const JetStruct       &rhs) const{
    //
    // Sort based on pt 
    //
    return lhs.jet_vec.Pt() > rhs.jet_vec.Pt();
  }
  
public:
  
  std::string fKey;
};

double weightXETrigSF(const float met_pt, unsigned metRunNumber, int syst=0) {
  double p0 = 242.3;
  double p1 = 82.86;
  double e0 = 0.003;
  double e1 = 0.075;
  double x = met_pt / 1.0e3;
  if (x < 1.0) { return 0; }
  if (x > 450) { x = 450; }
  double sf = 0.5*(1+TMath::Erf((x-p0)/(TMath::Sqrt(2)*p1)));
  if(sf<0) sf=0.0;
  if(sf > 1.5) sf=1.5;

  // linear parameterization of the systematics
  if(syst==1){ // up variation
    if(x<450.0) sf+=((e0)*(450-x)+e1)*0.6;
    else sf=1.0;
  }else if(syst==2){ // down
    if(x<450.0)sf-=((e0)*(450-x)+e1)*0.6;
    else sf=1.0;
  }
  return sf;
}

//----
void correctMET(TVector3 &metv, TLorentzVector jetv, bool add){
  TVector3 jetvm = jetv.Vect();
  if(add){
    metv+=jetvm;
  }else{
    metv-=jetvm;
  }
}

float smearWidth(float pt, float eta){

  if(fabs(eta)<0.7){
    if(pt>40e3) return 0.8e3;
    else return 2.0e3;
  }else if(fabs(eta)<1.5){
    if(pt>40e3) return 1.2e3;
    else return 2.5e3;
  }else if(fabs(eta)<2.5){
    if(pt>40e3) return 1.8e3;
    else return 3.4e3;
  }else{
    if(pt>40e3) return 3.5e3;
    else return 4.5e3;
  }
  //if(fabs(eta)>2.5) return 4.0e3;
  //return 3.0e3;
}

bool passMETSelection(TLorentzVector jet, float jvt){
  if(jet.Pt()<20e3) return false;
  if(fabs(jet.Eta())>2.4) return true;
  if(fabs(jvt)<=0.5 && jet.Pt()<60e3) return false;
  return true;
}

void smearPhJets(std::string treeNmae="SinglePhoton",std::string period="A") {
  // Example of Root macro to copy a subset of a Tree to a new Tree
  // Only selected entries are copied to the new Tree.
  // The input file has been generated by the program in $ROOTSYS/test/Event
  bool doSmearing=true;
  bool debug=false;
  unsigned nSamples=20; 
  
  std::string outdir = "/tmp/v41"+period+"gam";
  //Get old file, old tree and set top branch address
  std::string oldfileNmae=outdir+"/"+treeNmae+".root";
  TFile *oldfile = new TFile(oldfileNmae.c_str());
  std::cout << "File: " << oldfile << std::endl;
  std::string oldtreeNmae=treeNmae+"Nominal";
  TTree *oldtree = (TTree*)oldfile->Get(oldtreeNmae.c_str());
  std::cout << "Tree: " << oldtree << " " << oldtreeNmae << std::endl;  
  Long64_t nentries = oldtree->GetEntries();

  // turn off weights
  for(const auto &pleaf : *(oldtree->GetListOfLeaves())){
    std::string leafName = pleaf->GetName();
    if(leafName.size()>1 && leafName[0]==string("w")){
      oldtree->SetBranchStatus(leafName.c_str(),0);
      std::cout << "Turned off: " << leafName << std::endl;
    }
  }

  TRandom3 m_rand;

  std::vector<float> copy_el_pt;
  std::vector<float> copy_el_phi;
  std::vector<float> copy_el_eta;
  std::vector<float> copy_baseel_pt;
  std::vector<float> copy_baseel_phi;
  std::vector<float> copy_baseel_eta;
  
  std::vector<float> *el_pt=new std::vector<float>();
  std::vector<float> *el_phi=new std::vector<float>();  
  std::vector<float> *el_eta=new std::vector<float>();
  std::vector<float> *baseel_pt=new std::vector<float>();
  std::vector<float> *baseel_phi=new std::vector<float>();  
  std::vector<float> *baseel_eta=new std::vector<float>(); 
  std::vector<float> *ph_phi=new std::vector<float>();
  std::vector<float> *ph_eta=new std::vector<float>();
  std::vector<float> *ph_pt=new std::vector<float>();
  std::vector<float> *jet_phi=new std::vector<float>();
  std::vector<float> *jet_eta=new std::vector<float>();
  std::vector<float> *jet_pt=new std::vector<float>();
  std::vector<float> *jet_m=new std::vector<float>();
  std::vector<float> *jet_jvt=new std::vector<float>();
  std::vector<float> *jet_fjvt=new std::vector<float>();
  std::vector<float> *jet_btag_weight=new std::vector<float>();
  std::vector<float> *jet_timing=new std::vector<float>();
  std::vector<int> *jet_PartonTruthLabelID=new std::vector<int>();
  std::vector<int> *jet_ConeTruthLabelID=new std::vector<int>();
  
  std::vector<float> *basejet_phi=new std::vector<float>();
  std::vector<float> *basejet_eta=new std::vector<float>();
  std::vector<float> *basejet_pt=new std::vector<float>();
  std::vector<float> *basejet_m=new std::vector<float>();
  std::vector<float> *basejet_jvt=new std::vector<float>();  
  std::vector<float> *basejet_fjvt=new std::vector<float>();

  //jet_btag_weight?
	  //jet_timing?
	  //jet_PartonTruthLabelID?
	  //jet_ConeTruthLabelID?
  int runNumber   = 0;
  int n_baseel   = 0;
  int n_el   = 0;
  int n_el_w   = 0;
  int n_ph   = 0;
  int n_basemu   = 0;
  float met_truth_et=0;
  float met_tst_et=0;
  double met_cst_jet=0;  
  float met_cst_phi=0;  
  float met_tst_nolep_et=0;
  float met_tst_phi=0;
  float met_tst_nolep_phi=0;  
  float SherpaVTruthPt=0;
  float truth_V_dressed_pt=0;
  double truth_jj_mass=0;
  double jj_mass=0.0;
  double jj_dphi=0.0;
  double jj_deta=0.0;
  int n_jet=0;
  float w=0.0;
  float puWeight=0.0;  
  double met_tst_j1_dphi =0;
  double met_tst_j2_dphi =0;
  double met_tst_nolep_j1_dphi =0;
  double met_tst_nolep_j2_dphi =0;

  float xeSFTrigWeight=0.0;
  float xeSFTrigWeight__1up=0.0;
  float xeSFTrigWeight__1down=0.0;
  float xeSFTrigWeight_nomu=0.0;
  float xeSFTrigWeight_nomu__1up=0.0;
  float xeSFTrigWeight_nomu__1down=0.0;
  int trigger_met_encodedv2=0;
  int trigger_met=0;
  oldtree->SetBranchAddress("w",&w);
  oldtree->SetBranchAddress("puWeight",&puWeight);
  oldtree->SetBranchAddress("runNumber",&runNumber);
  oldtree->SetBranchAddress("n_baseel",&n_baseel);
  oldtree->SetBranchAddress("n_el",&n_el);
  oldtree->SetBranchAddress("n_ph",&n_ph);
  oldtree->SetBranchAddress("el_pt",&el_pt);
  oldtree->SetBranchAddress("el_eta",&el_eta);
  oldtree->SetBranchAddress("el_phi",&el_phi);
  oldtree->SetBranchAddress("baseel_pt",&baseel_pt);
  oldtree->SetBranchAddress("baseel_eta",&baseel_eta);
  oldtree->SetBranchAddress("baseel_phi",&baseel_phi);
  
  oldtree->SetBranchAddress("jet_pt",&jet_pt);
  oldtree->SetBranchAddress("jet_eta",&jet_eta);
  oldtree->SetBranchAddress("jet_phi",&jet_phi);
  oldtree->SetBranchAddress("jet_m",&jet_m);
  oldtree->SetBranchAddress("jet_jvt",&jet_jvt);
  oldtree->SetBranchAddress("jet_fjvt",&jet_fjvt);
  oldtree->SetBranchAddress("jet_btag_weight",&jet_btag_weight);
  oldtree->SetBranchAddress("jet_timing",&jet_timing);
  oldtree->SetBranchAddress("jet_PartonTruthLabelID",&jet_PartonTruthLabelID);
  oldtree->SetBranchAddress("jet_ConeTruthLabelID",&jet_ConeTruthLabelID);
  
  oldtree->SetBranchAddress("basejet_pt", &basejet_pt);
  oldtree->SetBranchAddress("basejet_eta",&basejet_eta);
  oldtree->SetBranchAddress("basejet_phi",&basejet_phi);
  oldtree->SetBranchAddress("basejet_m",  &basejet_m);
  oldtree->SetBranchAddress("basejet_jvt",&basejet_jvt);
  oldtree->SetBranchAddress("basejet_fjvt",&basejet_fjvt);
  
  oldtree->SetBranchAddress("met_tst_j1_dphi",&met_tst_j1_dphi);
  oldtree->SetBranchAddress("met_tst_j2_dphi",&met_tst_j2_dphi);
  oldtree->SetBranchAddress("met_tst_nolep_j1_dphi",&met_tst_nolep_j1_dphi);
  oldtree->SetBranchAddress("met_tst_nolep_j2_dphi",&met_tst_nolep_j2_dphi);  
  
  oldtree->SetBranchAddress("ph_pt",&ph_pt);
  oldtree->SetBranchAddress("ph_eta",&ph_eta);
  oldtree->SetBranchAddress("ph_phi",&ph_phi);
  oldtree->SetBranchAddress("n_el_w",&n_el_w);
  oldtree->SetBranchAddress("n_basemu",&n_basemu);
  oldtree->SetBranchAddress("met_truth_et",&met_truth_et);
  oldtree->SetBranchAddress("met_tst_et",&met_tst_et);
  oldtree->SetBranchAddress("met_cst_jet",&met_cst_jet);
  oldtree->SetBranchAddress("met_cst_phi",&met_cst_phi);
  oldtree->SetBranchAddress("met_tst_nolep_et",&met_tst_nolep_et);
  oldtree->SetBranchAddress("met_tst_phi",&met_tst_phi);
  oldtree->SetBranchAddress("met_tst_nolep_phi",&met_tst_nolep_phi);
  oldtree->SetBranchAddress("jj_mass",&jj_mass);
  oldtree->SetBranchAddress("jj_deta",&jj_deta);
  oldtree->SetBranchAddress("jj_dphi",&jj_dphi);
  oldtree->SetBranchAddress("n_jet",&n_jet);
  
  oldtree->SetBranchAddress("trigger_met_encodedv2",     &trigger_met_encodedv2);
  oldtree->SetBranchAddress("trigger_met",     &trigger_met);
  oldtree->SetBranchAddress("xeSFTrigWeight",            &xeSFTrigWeight);
  oldtree->SetBranchAddress("xeSFTrigWeight__1up",       &xeSFTrigWeight__1up);
  oldtree->SetBranchAddress("xeSFTrigWeight__1down",     &xeSFTrigWeight__1down);
  oldtree->SetBranchAddress("xeSFTrigWeight_nomu",       &xeSFTrigWeight_nomu);
  oldtree->SetBranchAddress("xeSFTrigWeight_nomu__1up",  &xeSFTrigWeight_nomu__1up);
  oldtree->SetBranchAddress("xeSFTrigWeight_nomu__1down",&xeSFTrigWeight_nomu__1down);  
  
  oldtree->SetBranchAddress("truth_jj_mass",&truth_jj_mass);
  oldtree->SetBranchAddress("truth_V_dressed_pt",&truth_V_dressed_pt);
  oldtree->SetBranchAddress("SherpaVTruthPt",&SherpaVTruthPt);

  //Create a new file + a clone of old tree in new file
  std::string outfileName=outdir+"/smallv2"+treeNmae+".root";
  outfileName="/tmp/v41"+period+"Gam/smallv2"+treeNmae+".root";
  TFile *newfile = new TFile(outfileName.c_str(),"recreate");
  TTree *newtree = oldtree->CloneTree(0);
  //newtree->SetName("SmearPhJetsNominal");
  //newtree->SetTitle("SmearPhJetsNominal");
  newtree->SetName("SinglePhotonNominal");
  newtree->SetTitle("SinglePhotonNominal");
  float wGJetTrig__1up = 0.0;
  float wGJetTrig__1down = 0.0;
  float wGJetCore__1up = 0.0;
  float wGJetCore__1down = 0.0;
    
  newtree->Branch("wGJetTrig__1up",&wGJetTrig__1up);
  newtree->Branch("wGJetTrig__1down",&wGJetTrig__1down);
  newtree->Branch("wGJetCore__1up",&wGJetCore__1up);
  newtree->Branch("wGJetCore__1down",&wGJetCore__1down);
  TH1F *cutflow = new TH1F("cutflow","cutflow",15,0.5,15.5);
  cutflow->SetDirectory(newfile);
  
  TVector3 met_before,met_nolep_before,newel,met_after,met_nolep_after,met_cst_before,met_cst_after;
  TLorentzVector tmptvl,smeared_jet_bit,jet1,jet2,photon;
  //std::vector<TLorentzVector> alljetvec_before, alljetvec_after;
  std::vector<JetStruct> alljetvec_before,alljetvec_after;
  JetStruct tmpJetStruct;
  std::vector<bool> passMETCuts;
  int periodSeed=0;
  if(period=="D") periodSeed=10;
  else if(period=="E") periodSeed=20;
  m_rand.SetSeed(runNumber+periodSeed);
  std::cout << "setting seed: " << (runNumber+periodSeed) << std::endl;
  for (Long64_t i=0;i<nentries; i++) {
    if((i%10000)==0) std::cout <<"evt: " << i << std::endl;
    //if(i>30000) break;
    oldtree->GetEntry(i);
    cutflow->Fill(1);
    cutflow->Fill(2,w);
    if (n_ph==1){ //  && n_el==0 && n_el_w==0 && n_baseel==0 // no need to require these 
      
      //divide by the number of smearings
      w/=float(nSamples);
      if(puWeight>1.3) w/=puWeight; // remove large pileup weights
      if(w>0.0) w*=0.58;
      if(w<0.0) w*=-0.58;
      //w*=1.11; // normalizing to the low met region

      if(ph_pt->size()>0) photon.SetPtEtaPhiM(ph_pt->at(0), ph_eta->at(0), ph_phi->at(0), 0.0);
      
      // Load the jet vectors
      alljetvec_before.clear();
      passMETCuts.clear();
      for(unsigned ijet=0; ijet<jet_pt->size(); ++ijet){
	tmptvl.SetPtEtaPhiM(jet_pt->at(ijet),jet_eta->at(ijet), jet_phi->at(ijet), jet_m->at(ijet));
	// filling
	tmpJetStruct.jet_vec = tmptvl;
	tmpJetStruct.jet_pt = jet_pt->at(ijet);
	tmpJetStruct.jet_eta = jet_eta->at(ijet);
	tmpJetStruct.jet_phi = jet_phi->at(ijet);
	tmpJetStruct.jet_m = jet_m->at(ijet);
	tmpJetStruct.jet_jvt = jet_jvt->at(ijet);	
	tmpJetStruct.jet_fjvt = jet_fjvt->at(ijet);	
	tmpJetStruct.jet_btag_weight = jet_btag_weight->at(ijet);	
	tmpJetStruct.jet_timing = jet_timing->at(ijet);	
	tmpJetStruct.jet_PartonTruthLabelID = jet_PartonTruthLabelID->at(ijet);	
	tmpJetStruct.jet_ConeTruthLabelID = jet_ConeTruthLabelID->at(ijet);	

	alljetvec_before.push_back(tmpJetStruct);
	passMETCuts.push_back(passMETSelection(tmptvl,jet_jvt->at(ijet)));
      }
      if(debug) std::cout << "filled jet" << std::endl;      
      for(unsigned ijet=0; ijet<basejet_pt->size(); ++ijet){
	tmptvl.SetPtEtaPhiM(basejet_pt->at(ijet),basejet_eta->at(ijet), basejet_phi->at(ijet), basejet_m->at(ijet));
	// filling
	tmpJetStruct.jet_vec = tmptvl;
	tmpJetStruct.jet_pt = basejet_pt->at(ijet);
	tmpJetStruct.jet_eta = basejet_eta->at(ijet);
	tmpJetStruct.jet_phi = basejet_phi->at(ijet);
	tmpJetStruct.jet_m = basejet_m->at(ijet);
	tmpJetStruct.jet_jvt = basejet_jvt->at(ijet);	
	tmpJetStruct.jet_fjvt = basejet_fjvt->at(ijet);
	tmpJetStruct.jet_btag_weight = 0.0;
	tmpJetStruct.jet_timing = 0.0;
	tmpJetStruct.jet_PartonTruthLabelID = 1;
	tmpJetStruct.jet_ConeTruthLabelID = 1;
	
	alljetvec_before.push_back(tmpJetStruct);
	passMETCuts.push_back(passMETSelection(tmptvl,basejet_jvt->at(ijet)));	
      }
      if(debug) std::cout << "filled basejet" << std::endl;
      // clear the base jets as they really are not useful in the smeared versions
      basejet_pt->clear();
      basejet_eta->clear();
      basejet_phi->clear();
      basejet_m->clear();
      basejet_jvt->clear();
      basejet_fjvt->clear();

      // set variables before smearing
      met_before.SetPtEtaPhi(met_tst_et,0.0,met_tst_phi);
      met_cst_before.SetPtEtaPhi(met_cst_jet,0.0,met_cst_phi);      
      met_nolep_before.SetPtEtaPhi(met_tst_nolep_et,0.0,met_tst_nolep_phi);
      
      // run the smearing
      for(unsigned sample=0; sample<nSamples; ++sample){
	alljetvec_after.clear();
	if(debug) std::cout << "sample: " << sample << std::endl;
	// smear jets
	for(unsigned ijet=0;ijet<alljetvec_before.size(); ++ijet){
	  tmptvl=alljetvec_before.at(ijet).jet_vec;
	  // apply the smearing
	  float energy_smear = m_rand.Gaus(0.0,smearWidth(tmptvl.Pt(),tmptvl.Eta()));
	  float rand_deta = m_rand.Gaus(0.0,0.05);	  
	  float rand_dphi = m_rand.Gaus(0.0,0.05);	  
	  smeared_jet_bit.SetPtEtaPhiM( fabs(energy_smear), tmptvl.Eta()+rand_deta, tmptvl.Phi()+rand_dphi, 0.0); // currently just a pT & energy change & jet angle. not changing the mass
	  if(doSmearing){
	    if(energy_smear>0.0) tmptvl+=smeared_jet_bit;
	    else                 tmptvl-=smeared_jet_bit;
	  }
	  // filling
	  tmpJetStruct.jet_vec = tmptvl;
	  tmpJetStruct.jet_pt = tmptvl.Pt();
	  tmpJetStruct.jet_eta = tmptvl.Eta();
	  tmpJetStruct.jet_phi = tmptvl.Phi();
	  tmpJetStruct.jet_m = tmptvl.M();
	  tmpJetStruct.jet_jvt = alljetvec_before.at(ijet).jet_jvt;
	  tmpJetStruct.jet_fjvt = alljetvec_before.at(ijet).jet_fjvt;
	  tmpJetStruct.jet_btag_weight = alljetvec_before.at(ijet).jet_btag_weight;
	  tmpJetStruct.jet_timing = alljetvec_before.at(ijet).jet_timing;
	  tmpJetStruct.jet_PartonTruthLabelID = alljetvec_before.at(ijet).jet_PartonTruthLabelID;
	  tmpJetStruct.jet_ConeTruthLabelID = alljetvec_before.at(ijet).jet_ConeTruthLabelID;
	  
	  alljetvec_after.push_back(tmpJetStruct);
	  if(debug){ std::cout << "jet before: " << alljetvec_before.at(ijet).Pt() << "  after: " << tmptvl.Pt() << std::endl; }
	}
	if(debug) std::cout << "smeared jets done " << std::endl;

	// update the MET
	met_after=met_before;
	met_cst_after=met_cst_before;	
	met_nolep_after=met_nolep_before;
	for(unsigned ijet=0;ijet<alljetvec_after.size(); ++ijet){

	  // jet is too close to the photon
	  if(photon.DeltaR(alljetvec_after.at(ijet).jet_vec)<0.35) continue;
	  
	  bool newJetPassMETSel = passMETSelection(alljetvec_after.at(ijet).jet_vec, alljetvec_after.at(ijet).jet_jvt);
	  if(passMETCuts.at(ijet) && (!newJetPassMETSel)){
	    correctMET(met_after, alljetvec_before.at(ijet).jet_vec, true); // remove old jet. so add it back
	    correctMET(met_nolep_after, alljetvec_before.at(ijet).jet_vec, true); // remove old jet. so add it back
	    if(!doSmearing){
	      std::cout << "Should not happen - jet passed before but not now: "  << alljetvec_before.at(ijet).Pt()
			<< " " << alljetvec_before.at(ijet).jet_pt
			<< " " << alljetvec_before.at(ijet).jet_eta
			<<std::endl;
	    }
	  }else if((!(passMETCuts.at(ijet))) && newJetPassMETSel){
	    correctMET(met_after, alljetvec_after.at(ijet).jet_vec, false); // subtract it. negative vector sum jazz
	    correctMET(met_nolep_after, alljetvec_after.at(ijet).jet_vec, false); // subtract it. negative vector sum jazz
	    if(!doSmearing){
	      std::cout << "Should not happen - jet passed after but not BEFORE: "
			<< alljetvec_before.at(ijet).Pt()
			<< " " << alljetvec_before.at(ijet).jet_pt
			<< " " << alljetvec_before.at(ijet).jet_eta
			<< " jvt: " << alljetvec_before.at(ijet).jet_jvt
			<< " after: " << alljetvec_after.at(ijet).Pt()
			<< " " << alljetvec_after.at(ijet).jet_pt
			<< " " << alljetvec_after.at(ijet).jet_eta
			<< " jvt: " << alljetvec_after.at(ijet).jet_jvt		
			<<std::endl;
	    }
	  }else if(passMETCuts.at(ijet) && newJetPassMETSel){
	    correctMET(met_after, alljetvec_before.at(ijet).jet_vec, true); // remove old jet. so add it back smeared
	    correctMET(met_after, alljetvec_after.at(ijet).jet_vec, false); // subtract it. negative vector sum jazz
	    correctMET(met_nolep_after, alljetvec_before.at(ijet).jet_vec, true); // remove old jet. so add it back smeared
	    correctMET(met_nolep_after, alljetvec_after.at(ijet).jet_vec, false); // subtract it. negative vector sum jazz
	    if(!doSmearing && fabs(alljetvec_before.at(ijet).jet_pt-alljetvec_after.at(ijet).jet_pt)>0.5){
	      std::cout << "Should not happen - jet passed AFTER and BEFORE: "
			<< alljetvec_before.at(ijet).Pt()
			<< " " << alljetvec_before.at(ijet).jet_pt
			<< " " << alljetvec_before.at(ijet).jet_eta
			<< " after: " << alljetvec_after.at(ijet).Pt()
			<< " " << alljetvec_after.at(ijet).jet_pt
			<< " " << alljetvec_after.at(ijet).jet_eta
			<<std::endl;
	    }
	  }
	  // sanity check because overlap removal is not perfect.
	  if(n_baseel==0 && n_basemu==0){
	    if(met_nolep_after.Pt()<met_after.Pt()) met_nolep_after=met_after;
	  }
	  // do the vector sum of all jets - only do this for jets that we are sure about.
	  if(alljetvec_before.at(ijet).Pt()>30e3 && alljetvec_after.at(ijet).Pt()>30e3){
	    bool passCSTBefore = alljetvec_before.at(ijet).Pt()>20e3;
	    bool passCSTAfter = alljetvec_after.at(ijet).Pt()>20e3;
	    if(passCSTBefore && !passCSTAfter){
	      correctMET(met_cst_after, alljetvec_before.at(ijet).jet_vec, true); // remove old jet. so add it back
	    }else if(!passCSTBefore && passCSTAfter){
	      correctMET(met_cst_after, alljetvec_after.at(ijet).jet_vec, false); // subtract it. negative vector sum jazz
	    }else if(passCSTBefore && passCSTAfter){
	      correctMET(met_cst_after, alljetvec_before.at(ijet).jet_vec, true); // remove old jet. so add it back
	      correctMET(met_cst_after, alljetvec_after.at(ijet).jet_vec, false); // subtract it. negative vector sum jazz
	    }
	  }
	}// end correcting the MET
	if(debug) std::cout << "update met done " << std::endl;
	
	// count jets. doing this by removing those that don't pass cuts		
	for(unsigned ijet=0;ijet<alljetvec_after.size(); ++ijet){

	  // jet is too close to the photon
	  if(photon.DeltaR(alljetvec_after.at(ijet).jet_vec)<0.35){
	    alljetvec_after.erase(alljetvec_after.begin()+ijet);
	    --ijet;
	    continue;
	  }
	  // jet is too low pT
	  if(alljetvec_after.at(ijet).Pt()<25.0e3){
	    alljetvec_after.erase(alljetvec_after.begin()+ijet);
	    --ijet;
	    continue;
	  }
	  else if(alljetvec_after.at(ijet).Pt()<60.0e3 && fabs(alljetvec_after.at(ijet).Eta())<2.4 && alljetvec_after.at(ijet).jet_jvt<0.11){
	    alljetvec_after.erase(alljetvec_after.begin()+ijet);
	    --ijet;
	    continue;
	  }
	  //jet_jvt->push_back(alljetvec_after.at(ijet).jet_jvt); 
	}
	
	std::sort(alljetvec_after.begin(),alljetvec_after.end(),SortPhysicsObject("pt"));
	// set new variables
	jet_pt->clear();
	jet_eta->clear();
	jet_phi->clear();
	jet_m->clear();
	jet_jvt->clear();
	jet_fjvt->clear();
	jet_btag_weight->clear();
	jet_timing->clear();
	jet_btag_weight->clear();
	jet_PartonTruthLabelID->clear();
	jet_ConeTruthLabelID->clear();

	for(unsigned ijet=0;ijet<alljetvec_after.size(); ++ijet){
	  jet_pt->push_back(alljetvec_after.at(ijet).Pt());
	  jet_eta->push_back(alljetvec_after.at(ijet).Eta());
	  jet_phi->push_back(alljetvec_after.at(ijet).Phi());
	  jet_m->push_back(alljetvec_after.at(ijet).M());
	  jet_jvt->push_back(alljetvec_after.at(ijet).jet_jvt);
	  jet_fjvt->push_back(alljetvec_after.at(ijet).jet_fjvt);
	  jet_timing->push_back(alljetvec_after.at(ijet).jet_timing);	  
	  jet_btag_weight->push_back(alljetvec_after.at(ijet).jet_btag_weight);
	  jet_PartonTruthLabelID->push_back(alljetvec_after.at(ijet).jet_PartonTruthLabelID);
	  jet_ConeTruthLabelID->push_back(alljetvec_after.at(ijet).jet_ConeTruthLabelID);
	}
	jj_mass=0.0;
	jj_deta=0.0;
	jj_dphi=0.0;
	n_jet=alljetvec_after.size();
	
	met_tst_et=met_after.Pt();
	met_tst_phi=met_after.Phi();
	met_tst_nolep_et=met_nolep_after.Pt();
	met_tst_nolep_phi=met_nolep_after.Phi();
	met_cst_jet = met_cst_after.Pt();
	met_cst_phi = met_cst_after.Phi();
	if(alljetvec_after.size()>1){
	  jet1=alljetvec_after.at(0).jet_vec;
	  jet2=alljetvec_after.at(1).jet_vec;
	  met_tst_j1_dphi=fabs(jet1.Vect().DeltaPhi(met_after));
	  met_tst_j2_dphi=fabs(jet2.Vect().DeltaPhi(met_after));
	  met_tst_nolep_j1_dphi=fabs(jet1.Vect().DeltaPhi(met_nolep_after));
	  met_tst_nolep_j2_dphi=fabs(jet2.Vect().DeltaPhi(met_nolep_after));
	  jj_dphi = fabs(jet1.DeltaPhi(jet2));
	  jj_deta = fabs(jet1.Eta() - jet2.Eta());
	  jj_mass = (jet1 + jet2).M();
	}

	// update trigger SF
	xeSFTrigWeight        = weightXETrigSF(met_tst_et, 0, 0);
	xeSFTrigWeight__1up   = weightXETrigSF(met_tst_et, 0, 1);
	xeSFTrigWeight__1down = weightXETrigSF(met_tst_et, 0, 2);
	xeSFTrigWeight_nomu        = weightXETrigSF(met_tst_nolep_et, 0, 0);
	xeSFTrigWeight_nomu__1up   = weightXETrigSF(met_tst_nolep_et, 0, 1);
	xeSFTrigWeight_nomu__1down = weightXETrigSF(met_tst_nolep_et, 0, 2);

	// set the weight low for fake muons to avoid large weights
	if(n_basemu>0 && abs(w*36000)>0.5){
	  float sfMuon = 0.1/abs(w*36000);
	  w*=sfMuon;
	}
	
	// syst weights
	if(met_tst_et<200.0e3){ // weight grows with MET
	  float metposFrac = (200e3-met_tst_et)/200e3;
	  if(metposFrac<0.5) metposFrac=0.5;
	  wGJetTrig__1up=w*(1.0+0.5*metposFrac);
	  wGJetTrig__1down=w*(1.0-0.5*metposFrac);
	}else{
	  wGJetTrig__1up=w*1.05;
	  wGJetTrig__1down=w*0.95;
	}
	wGJetCore__1up=w*1.25;
	wGJetCore__1down=w*0.75;

	// set the met triggers to pass
	//(trigger_met_encodedv2& 0x2);
	trigger_met_encodedv2 |= 0x1; // pass 2015/6
	trigger_met_encodedv2 |= 0x2; // pass 2017
	trigger_met_encodedv2 |= 0x8; // pass 2018
	trigger_met=1;
	if(debug){
	  std::cout << "njet: " << n_jet << std::endl;
	  if(n_jet>1)
	    std::cout << "lead jet pT: " << jet_pt->at(0) << " sublead jet pT: " << jet_pt->at(1) << endl
		      << "   mjj: " << jj_mass << " detajj: " << jj_deta << endl
		      << "   met: " << met_tst_et << " met nolepton: " << met_tst_nolep_et
		      << std::endl;
	}

	// remove small numbers of jets
	cutflow->Fill(3,w);
	if(n_jet<2) continue;
	cutflow->Fill(4,w);
	if(jet_pt->at(0)<60e3) continue;
	cutflow->Fill(5,w);
	if(jet_pt->at(1)<40e3) continue;
	cutflow->Fill(6,w);
	if(jj_mass<250e3) continue;
	cutflow->Fill(7,w);
	if(met_tst_et<100e3 && met_tst_nolep_et<100e3) continue;
	cutflow->Fill(8,w);
	// filling for each smearing
	newtree->Fill();
      }
    }
    //event->Clear();
  }
  newtree->Print();
  newtree->AutoSave();
  cutflow->Write();
  newfile->Close();
  oldfile->Close();
  delete oldfile;
  delete newfile;
}
